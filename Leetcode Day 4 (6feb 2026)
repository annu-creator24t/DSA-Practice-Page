<-------------56.Merge Interval----------------->

<------------------Bruteforce-------------------->

import java.util.*;

class Solution {
    public int[][] merge(int[][] intervals) {

        // Step 1: sort by start time
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        List<int[]> list = new ArrayList<>();
        for (int[] interval : intervals) {
            list.add(interval);
        }

        // Step 2: compare every interval with others
        int i = 0;
        while (i < list.size() - 1) {

            int[] curr = list.get(i);
            int[] next = list.get(i + 1);

            // overlap check
            if (curr[1] >= next[0]) {

                // merge
                curr[1] = Math.max(curr[1], next[1]);

                // remove merged interval
                list.remove(i + 1);
            } 
            else {
                i++;
            }
        }

        return list.toArray(new int[list.size()][]);
    }
}       
    //  Tc=O(nÂ²) ,Sc=O(n)


<------------------Optimal Approach------------------>

class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a,b)-> Integer.compare(a[0],b[0]));

        List<int[]>merged = new ArrayList<>();

        int[] prev = intervals[0];

        for(int i=1; i<intervals.length; i++){
            int[] next = intervals[i];

            if(next[0]<=prev[1]){
                prev[1]=Math.max(prev[1], next[1]);
            }else{
                merged.add(prev);
                prev=next;

            }
        }
        merged.add(prev);
        return merged.toArray(new int[merged.size()][]);
        
    }
}

// Tc=O(n log n) ,Sc=O(n)

<-------------152.Maximum Product subarray----------------->
class Solution {
    public int maxProduct(int[] nums) {
        int maxProduct = Integer.MIN_VALUE;

        for(int i= 0; i<nums.length;i++){
           int  currentProduct=1;
            for(int j= i; j<nums.length; j++){
                currentProduct =  currentProduct * nums[j];
                maxProduct = Math.max(maxProduct, currentProduct);
            }
        }
        return maxProduct;
        
    }
}
// TC: O(n^2) ,SC = O(1)


//Optimal Solution 

class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
       int leftProduct=1;
       int rightProduct=1;
       int maxProduct=nums[0];

       for(int i=0; i<nums.length; i++){

        leftProduct=leftProduct == 0 ? 1 : leftProduct;
         rightProduct=rightProduct == 0 ? 1 : rightProduct;
        // prefixproduct
        leftProduct=leftProduct*nums[i];
        // sufficproduct
        rightProduct = rightProduct * nums[n - i - 1];
        maxProduct=Math.max(maxProduct,Math.max(leftProduct,rightProduct));
       }
        return maxProduct;
        
    }   
}

// TC: O(n) ,SC = O(1)
